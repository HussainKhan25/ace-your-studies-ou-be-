<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Study Quest - Educational Adventure</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Space+Mono:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Orbitron', monospace;
            background: linear-gradient(135deg, #0a0f2e 0%, #1a237e 50%, #283593 100%);
            color: white;
            overflow: hidden;
            user-select: none;
        }
        
        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        /* Game Header */
        .game-header {
            background: rgba(10, 15, 46, 0.9);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #00bcd4;
            box-shadow: 0 0 20px rgba(0, 188, 212, 0.3);
            z-index: 1000;
        }
        
        .score-info {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .score-item {
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .score-value {
            color: #00e676;
            text-shadow: 0 0 10px rgba(0, 230, 118, 0.5);
        }
        
        .lives {
            display: flex;
            gap: 5px;
        }
        
        .life {
            width: 25px;
            height: 25px;
            background: #e91e63;
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(233, 30, 99, 0.6);
            position: relative;
        }
        
        .life::before {
            content: 'üìö';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
        }
        
        /* Game Canvas */
        .game-area {
            flex: 1;
            position: relative;
            background: linear-gradient(45deg, #0a0f2e, #1a237e);
            overflow: hidden;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1a237e 0%, #0a0f2e 70%);
            border: 2px solid #00bcd4;
            box-shadow: inset 0 0 50px rgba(0, 188, 212, 0.2);
            display: block;
        }
        
        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #0a0f2e 0%, #1a237e 50%, #283593 100%);
            z-index: 2000;
            transition: all 0.5s ease;
        }
        
        .screen.hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.9);
        }
        
        .screen h1 {
            font-size: 3rem;
            font-weight: 900;
            text-align: center;
            margin-bottom: 2rem;
            background: linear-gradient(45deg, #00e676, #4fc3f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(79, 195, 247, 0.5);
        }
        
        .screen p {
            font-size: 1.2rem;
            text-align: center;
            margin-bottom: 2rem;
            color: #b0bec5;
            max-width: 600px;
        }
        
        .btn {
            padding: 15px 30px;
            background: linear-gradient(45deg, #00e676, #4caf50);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 230, 118, 0.4);
            transition: all 0.3s ease;
            font-family: 'Orbitron', monospace;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 30px rgba(0, 230, 118, 0.6);
        }
        
        .btn.secondary {
            background: linear-gradient(45deg, #00bcd4, #26c6da);
            box-shadow: 0 0 20px rgba(0, 188, 212, 0.4);
        }
        
        .btn.secondary:hover {
            box-shadow: 0 5px 30px rgba(0, 188, 212, 0.6);
        }
        
        /* Question Modal */
        .question-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            transition: all 0.3s ease;
        }
        
        .question-modal.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .question-content {
            background: linear-gradient(135deg, #1a237e, #283593);
            padding: 2rem;
            border-radius: 16px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            border: 2px solid #00bcd4;
            box-shadow: 0 0 50px rgba(0, 188, 212, 0.3);
        }
        
        .question-text {
            font-size: 1.3rem;
            margin-bottom: 2rem;
            line-height: 1.6;
            color: white;
        }
        
        .answer-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 2rem;
        }
        
        .answer-btn {
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Space Mono', monospace;
        }
        
        .answer-btn:hover {
            background: rgba(0, 230, 118, 0.2);
            border-color: #00e676;
            transform: translateY(-2px);
        }
        
        .answer-btn.correct {
            background: linear-gradient(45deg, #4caf50, #66bb6a);
            border-color: #4caf50;
        }
        
        .answer-btn.incorrect {
            background: linear-gradient(45deg, #f44336, #ef5350);
            border-color: #f44336;
        }
        
        /* Controls */
        .controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1001;
        }
        
        .control-pad {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 5px;
            width: 120px;
            height: 120px;
        }
        
        .control-btn {
            background: rgba(0, 188, 212, 0.3);
            border: 2px solid #00bcd4;
            border-radius: 8px;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .control-btn:hover {
            background: rgba(0, 188, 212, 0.5);
            transform: scale(1.1);
        }
        
        .control-btn.up { grid-column: 2; grid-row: 1; }
        .control-btn.left { grid-column: 1; grid-row: 2; }
        .control-btn.right { grid-column: 3; grid-row: 2; }
        .control-btn.down { grid-column: 2; grid-row: 3; }
        
        /* Question Counter */
        .question-counter {
            font-size: 1.1rem;
            color: #ffc107;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .game-header {
                padding: 5px 10px;
                flex-wrap: wrap;
                gap: 10px;
            }
            
            .score-info {
                gap: 10px;
                font-size: 0.9rem;
            }
            
            .screen h1 {
                font-size: 2rem;
            }
            
            .screen p {
                font-size: 1rem;
                padding: 0 1rem;
            }
            
            .question-content {
                padding: 1rem;
                margin: 1rem;
            }
            
            .answer-options {
                grid-template-columns: 1fr;
            }
            
            .controls {
                bottom: 10px;
                right: 10px;
            }
            
            .control-pad {
                width: 100px;
                height: 100px;
            }
        }
        
        @media (max-width: 480px) {
            .screen h1 {
                font-size: 1.5rem;
            }
            
            .control-pad {
                width: 80px;
                height: 80px;
            }
            
            .control-btn {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Start Screen -->
        <div class="screen" id="startScreen">
            <h1>üìö STUDY QUEST</h1>
            <p>Navigate through distractions, collect all 8 knowledge keys, and answer questions correctly to win!</p>
            <p>Use arrow keys or on-screen controls to move. Get all 8 questions right to achieve victory!</p>
            <button class="btn" onclick="startGame()">START ADVENTURE</button>
        </div>
        
        <!-- Game Over Screen -->
        <div class="screen hidden" id="gameOverScreen">
            <h1>üíÄ GAME OVER</h1>
            <p>Don't give up! Knowledge comes through persistence!</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Correct Answers: <span id="finalCorrectAnswers">0</span>/8</p>
            <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                <button class="btn" onclick="restartGame()">TRY AGAIN</button>
                <button class="btn secondary" onclick="showStartScreen()">MAIN MENU</button>
            </div>
        </div>
        
        <!-- Victory Screen -->
        <div class="screen hidden" id="victoryScreen">
            <h1>üèÜ CONGRATULATIONS!</h1>
            <p>Perfect! You've answered all 8 questions correctly and mastered the knowledge!</p>
            <p>Final Score: <span id="victoryScore">0</span></p>
            <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                <button class="btn" onclick="restartGame()">PLAY AGAIN</button>
                <button class="btn secondary" onclick="showStartScreen()">MAIN MENU</button>
            </div>
        </div>
        
        <!-- Game Header -->
        <div class="game-header" id="gameHeader" style="display: none;">
            <div class="score-info">
                <div class="score-item">Score: <span class="score-value" id="score">0</span></div>
                <div class="score-item">Keys: <span class="score-value" id="keys">0</span>/8</div>
                <div class="score-item">Correct: <span class="score-value" id="correctAnswers">0</span>/8</div>
                <div class="score-item">High Score: <span class="score-value" id="highScore">0</span></div>
            </div>
            <div class="lives" id="lives">
                <div class="life"></div>
                <div class="life"></div>
                <div class="life"></div>
            </div>
        </div>
        
        <!-- Game Area -->
        <div class="game-area" id="gameArea" style="display: none;">
            <canvas id="gameCanvas"></canvas>
        </div>
        
        <!-- Controls -->
        <div class="controls" id="controls" style="display: none;">
            <div class="control-pad">
                <button class="control-btn up" onclick="movePlayer('up')">‚Üë</button>
                <button class="control-btn left" onclick="movePlayer('left')">‚Üê</button>
                <button class="control-btn right" onclick="movePlayer('right')">‚Üí</button>
                <button class="control-btn down" onclick="movePlayer('down')">‚Üì</button>
            </div>
        </div>
        
        <!-- Question Modal -->
        <div class="question-modal hidden" id="questionModal">
            <div class="question-content">
                <div class="question-counter" id="questionCounter">Question 1 of 8</div>
                <h2 id="questionCategory" style="color: #00e676; margin-bottom: 1rem;"></h2>
                <div class="question-text" id="questionText"></div>
                <div class="answer-options" id="answerOptions"></div>
                <div style="text-align: center;">
                    <button class="btn secondary" id="skipQuestion" onclick="skipQuestion()">Skip Question (-50 points)</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game variables
        let gameState = {
            score: 0,
            lives: 3,
            keys: 0,
            correctAnswers: 0,
            totalQuestions: 8,
            highScore: parseInt(localStorage.getItem('studyQuestHighScore')) || 0,
            isPlaying: false,
            isPaused: false,
            questionsAnswered: 0
        };

        let gameCanvas, ctx;
        let player = { x: 50, y: 50, size: 40, speed: 4 };
        let enemies = [];
        let collectibles = [];
        let keyCollectibles = [];
        let walls = [];
        let gameLoopRunning = false;
        let usedQuestions = [];

        // Question bank
        const questionBank = {
            'Digital Electronics': [
                {
                    question: "What is the output of a NAND gate when both inputs are HIGH?",
                    options: ["HIGH", "LOW", "Undefined", "Floating"],
                    correct: 1
                },
                {
                    question: "In binary, what is 1011 + 1101?",
                    options: ["11000", "10110", "11010", "10100"],
                    correct: 0
                },
                {
                    question: "Which flip-flop is known as a 'toggle' flip-flop?",
                    options: ["SR flip-flop", "D flip-flop", "JK flip-flop", "T flip-flop"],
                    correct: 3
                },
                {
                    question: "What does NOT gate do to the input signal?",
                    options: ["Amplifies it", "Inverts it", "Delays it", "Filters it"],
                    correct: 1
                }
            ],
            'Data Structures & Algorithms': [
                {
                    question: "What is the time complexity of binary search?",
                    options: ["O(n)", "O(log n)", "O(n¬≤)", "O(1)"],
                    correct: 1
                },
                {
                    question: "Which data structure uses LIFO principle?",
                    options: ["Queue", "Stack", "Array", "Linked List"],
                    correct: 1
                },
                {
                    question: "What is the worst-case time complexity of QuickSort?",
                    options: ["O(n log n)", "O(n¬≤)", "O(n)", "O(log n)"],
                    correct: 1
                },
                {
                    question: "Which sorting algorithm is stable?",
                    options: ["Quick Sort", "Heap Sort", "Merge Sort", "Selection Sort"],
                    correct: 2
                }
            ],
            'Computer Networks': [
                {
                    question: "Which layer of OSI model handles routing?",
                    options: ["Data Link", "Network", "Transport", "Session"],
                    correct: 1
                },
                {
                    question: "What is the default port for HTTPS?",
                    options: ["80", "443", "21", "25"],
                    correct: 1
                },
                {
                    question: "What does TCP stand for?",
                    options: ["Transfer Control Protocol", "Transmission Control Protocol", "Transport Control Protocol", "Transfer Communication Protocol"],
                    correct: 1
                },
                {
                    question: "Which protocol is connectionless?",
                    options: ["TCP", "UDP", "HTTP", "FTP"],
                    correct: 1
                }
            ],
            'Artificial Intelligence': [
                {
                    question: "What is overfitting in machine learning?",
                    options: ["Model performs well on training data but poorly on test data", "Model performs poorly on both training and test data", "Model is too simple", "Model has too few parameters"],
                    correct: 0
                },
                {
                    question: "Which algorithm is commonly used for classification?",
                    options: ["K-means", "Support Vector Machine", "DBSCAN", "PCA"],
                    correct: 1
                },
                {
                    question: "What is a neural network?",
                    options: ["A biological brain", "A computing system inspired by biological neural networks", "A type of database", "A programming language"],
                    correct: 1
                },
                {
                    question: "What is supervised learning?",
                    options: ["Learning without labeled data", "Learning with labeled training data", "Learning by trial and error", "Learning by clustering"],
                    correct: 1
                }
            ],
            'Cybersecurity': [
                {
                    question: "What does AES stand for?",
                    options: ["Advanced Encryption Standard", "Automated Encryption System", "Advanced Electronic Security", "Automated Electronic Standard"],
                    correct: 0
                },
                {
                    question: "Which attack involves overwhelming a system with traffic?",
                    options: ["SQL Injection", "Cross-site Scripting", "DDoS", "Man-in-the-middle"],
                    correct: 2
                },
                {
                    question: "What is two-factor authentication?",
                    options: ["Using two passwords", "Using password and biometric", "Using two different encryption methods", "Using password and additional verification method"],
                    correct: 3
                },
                {
                    question: "What is a firewall?",
                    options: ["A type of virus", "A network security device", "An encryption algorithm", "A password manager"],
                    correct: 1
                }
            ]
        };

        // Initialize game
        document.addEventListener('DOMContentLoaded', function() {
            gameCanvas = document.getElementById('gameCanvas');
            ctx = gameCanvas.getContext('2d');
            
            // Update high score display
            document.getElementById('highScore').textContent = gameState.highScore;
            
            // Keyboard controls
            document.addEventListener('keydown', handleKeyPress);
            
            // Initialize canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        });

        function resizeCanvas() {
            const gameArea = document.getElementById('gameArea');
            gameCanvas.width = gameArea.clientWidth;
            gameCanvas.height = gameArea.clientHeight;
        }

        function handleKeyPress(e) {
            if (!gameState.isPlaying || gameState.isPaused) return;
            
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    e.preventDefault();
                    movePlayer('up');
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    e.preventDefault();
                    movePlayer('down');
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    e.preventDefault();
                    movePlayer('left');
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    e.preventDefault();
                    movePlayer('right');
                    break;
            }
        }

        function startGame() {
            gameState = {
                score: 0,
                lives: 3,
                keys: 0,
                correctAnswers: 0,
                totalQuestions: 8,
                highScore: parseInt(localStorage.getItem('studyQuestHighScore')) || 0,
                isPlaying: true,
                isPaused: false,
                questionsAnswered: 0
            };
            
            usedQuestions = [];
            showGameScreen();
            initializeLevel();
            if (!gameLoopRunning) {
                gameLoopRunning = true;
                gameLoop();
            }
        }

        function showGameScreen() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('victoryScreen').classList.add('hidden');
            
            document.getElementById('gameHeader').style.display = 'flex';
            document.getElementById('gameArea').style.display = 'block';
            document.getElementById('controls').style.display = 'block';
            
            updateUI();
        }

        function showStartScreen() {
            document.getElementById('startScreen').classList.remove('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('victoryScreen').classList.add('hidden');
            
            document.getElementById('gameHeader').style.display = 'none';
            document.getElementById('gameArea').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
            
            gameState.isPlaying = false;
            gameLoopRunning = false;
        }

        function initializeLevel() {
            // Reset level state
            gameState.keys = 0;
            
            // Initialize player position
            player.x = 60;
            player.y = 60;
            
            // Clear any existing game elements
            enemies = [];
            collectibles = [];
            keyCollectibles = [];
            walls = [];
            
            // Resize canvas and regenerate level
            setTimeout(() => {
                resizeCanvas();
                generateWalls();
                generateEnemies();
                generateCollectibles();
                generateKeys();
                updateUI();
            }, 100);
        }

        function generateWalls() {
            walls = [];
            const canvasWidth = gameCanvas.width;
            const canvasHeight = gameCanvas.height;
            const wallThickness = 10;
            
            // Border walls
            walls.push({ x: 0, y: 0, width: canvasWidth, height: wallThickness });
            walls.push({ x: 0, y: canvasHeight - wallThickness, width: canvasWidth, height: wallThickness });
            walls.push({ x: 0, y: 0, width: wallThickness, height: canvasHeight });
            walls.push({ x: canvasWidth - wallThickness, y: 0, width: wallThickness, height: canvasHeight });
            
            // Add some interior walls for challenge
            const levelWalls = 4;
            for (let i = 0; i < levelWalls; i++) {
                let x, y, width, height;
                let attempts = 0;
                do {
                    x = Math.random() * (canvasWidth - 200) + 100;
                    y = Math.random() * (canvasHeight - 200) + 100;
                    width = Math.random() * 80 + 40;
                    height = Math.random() * 80 + 40;
                    attempts++;
                } while (attempts < 20 && (
                    (x < 120 && y < 120) || // Don't block player start position
                    isAreaOccupied(x, y, width, height)
                ));
                
                if (attempts < 20) {
                    walls.push({ x, y, width, height });
                }
            }
        }

        function isAreaOccupied(x, y, width, height) {
            for (let wall of walls) {
                if (x < wall.x + wall.width && x + width > wall.x &&
                    y < wall.y + wall.height && y + height > wall.y) {
                    return true;
                }
            }
            return false;
        }

        function generateEnemies() {
            enemies = [];
            const enemyTypes = [
                { type: 'phone', emoji: 'üì±', speed: 0.8, color: '#ff5722' },
                { type: 'game', emoji: 'üéÆ', speed: 1.2, color: '#9c27b0' },
                { type: 'social', emoji: 'üì∫', speed: 0.6, color: '#ff9800' },
                { type: 'tv', emoji: 'üíª', speed: 1.0, color: '#795548' },
                { type: 'music', emoji: 'üéµ', speed: 0.9, color: '#e91e63' },
                { type: 'chat', emoji: 'üí¨', speed: 1.1, color: '#3f51b5' }
            ];
            
            // Generate exactly 6 enemies
            for (let i = 0; i < 6; i++) {
                const enemyType = enemyTypes[i % enemyTypes.length];
                let x, y;
                let attempts = 0;
                
                do {
                    x = Math.random() * (gameCanvas.width - 100) + 50;
                    y = Math.random() * (gameCanvas.height - 100) + 50;
                    attempts++;
                } while (attempts < 50 && (
                    (Math.abs(x - player.x) < 100 && Math.abs(y - player.y) < 100) ||
                    isColliding({ x, y, size: 35 }, walls)
                ));
                
                if (attempts < 50) {
                    enemies.push({
                        x: x,
                        y: y,
                        size: 35,
                        speed: enemyType.speed,
                        type: enemyType.type,
                        emoji: enemyType.emoji,
                        color: enemyType.color,
                        direction: Math.random() * 2 * Math.PI,
                        moveTimer: 0
                    });
                }
            }
        }

        function generateCollectibles() {
            collectibles = [];
            const collectibleCount = 20; // More collectibles for points
            
            for (let i = 0; i < collectibleCount; i++) {
                let x, y;
                let attempts = 0;
                do {
                    x = Math.random() * (gameCanvas.width - 50) + 25;
                    y = Math.random() * (gameCanvas.height - 50) + 25;
                    attempts++;
                } while (attempts < 50 && isColliding({ x, y, size: 25 }, walls));
                
                if (attempts < 50) {
                    collectibles.push({
                        x: x,
                        y: y,
                        size: 25,
                        points: 10,
                        emoji: 'üí°'
                    });
                }
            }
        }

        function generateKeys() {
            keyCollectibles = [];
            
            // Generate exactly 8 keys
            for (let i = 0; i < 8; i++) {
                let x, y;
                let attempts = 0;
                do {
                    x = Math.random() * (gameCanvas.width - 50) + 25;
                    y = Math.random() * (gameCanvas.height - 50) + 25;
                    attempts++;
                } while (attempts < 50 && (
                    isColliding({ x, y, size: 25 }, walls) ||
                    (Math.abs(x - player.x) < 80 && Math.abs(y - player.y) < 80)
                ));
                
                if (attempts < 50) {
                    keyCollectibles.push({
                        x: x,
                        y: y,
                        size: 25,
                        emoji: 'üîë'
                    });
                }
            }
        }

        function movePlayer(direction) {
            if (!gameState.isPlaying || gameState.isPaused) return;
            
            let newX = player.x;
            let newY = player.y;
            
            switch(direction) {
                case 'up':
                    newY -= player.speed;
                    break;
                case 'down':
                    newY += player.speed;
                    break;
                case 'left':
                    newX -= player.speed;
                    break;
                case 'right':
                    newX += player.speed;
                    break;
            }
            
            // Check wall collision
            const newPlayer = { x: newX, y: newY, size: player.size };
            
            if (!isColliding(newPlayer, walls)) {
                player.x = newX;
                player.y = newY;
            }
            
            // Check bounds
            player.x = Math.max(player.size/2, Math.min(gameCanvas.width - player.size/2, player.x));
            player.y = Math.max(player.size/2, Math.min(gameCanvas.height - player.size/2, player.y));
            
            // Check collectible collisions
            checkCollectibleCollisions();
            
            // Check enemy collisions
            checkEnemyCollisions();
        }

        function isColliding(obj, obstacles) {
            for (let obstacle of obstacles) {
                if (obj.x - obj.size/2 < obstacle.x + obstacle.width &&
                    obj.x + obj.size/2 > obstacle.x &&
                    obj.y - obj.size/2 < obstacle.y + obstacle.height &&
                    obj.y + obj.size/2 > obstacle.y) {
                    return true;
                }
            }
            return false;
        }

        function checkCollectibleCollisions() {
            collectibles = collectibles.filter(collectible => {
                const distance = Math.sqrt(
                    Math.pow(player.x - collectible.x, 2) + 
                    Math.pow(player.y - collectible.y, 2)
                );
                
                if (distance < player.size/2 + collectible.size/2) {
                    gameState.score += collectible.points;
                    updateUI();
                    return false;
                }
                return true;
            });
            
            // Check key collisions
            keyCollectibles = keyCollectibles.filter(key => {
                const distance = Math.sqrt(
                    Math.pow(player.x - key.x, 2) + 
                    Math.pow(player.y - key.y, 2)
                );
                
                if (distance < player.size/2 + key.size/2) {
                    gameState.keys++;
                    gameState.score += 50;
                    updateUI();
                    
                    // Show question immediately when key is collected
                    showQuestion();
                    return false;
                }
                return true;
            });
        }

        function checkEnemyCollisions() {
            for (let enemy of enemies) {
                const distance = Math.sqrt(
                    Math.pow(player.x - enemy.x, 2) + 
                    Math.pow(player.y - enemy.y, 2)
                );
                
                if (distance < player.size/2 + enemy.size/2) {
                    loseLife();
                    break;
                }
            }
        }

        function updateEnemies() {
            enemies.forEach(enemy => {
                enemy.moveTimer++;
                
                // Change direction occasionally
                if (enemy.moveTimer % 120 === 0) {
                    enemy.direction = Math.random() * 2 * Math.PI;
                }
                
                // Move enemy
                let newX = enemy.x + Math.cos(enemy.direction) * enemy.speed;
                let newY = enemy.y + Math.sin(enemy.direction) * enemy.speed;
                
                // Check wall collision
                const newEnemy = { x: newX, y: newY, size: enemy.size };
                if (!isColliding(newEnemy, walls)) {
                    enemy.x = newX;
                    enemy.y = newY;
                } else {
                    // Bounce off walls
                    enemy.direction = enemy.direction + Math.PI + (Math.random() - 0.5) * 0.5;
                }
                
                // Keep enemies in bounds
                if (enemy.x < enemy.size/2 || enemy.x > gameCanvas.width - enemy.size/2) {
                    enemy.direction = Math.PI - enemy.direction;
                }
                if (enemy.y < enemy.size/2 || enemy.y > gameCanvas.height - enemy.size/2) {
                    enemy.direction = -enemy.direction;
                }
                
                enemy.x = Math.max(enemy.size/2, Math.min(gameCanvas.width - enemy.size/2, enemy.x));
                enemy.y = Math.max(enemy.size/2, Math.min(gameCanvas.height - enemy.size/2, enemy.y));
            });
        }

        function getRandomQuestion() {
            const categories = Object.keys(questionBank);
            let availableQuestions = [];
            
            // Collect all questions that haven't been used
            categories.forEach(category => {
                questionBank[category].forEach((question, index) => {
                    const questionId = `${category}_${index}`;
                    if (!usedQuestions.includes(questionId)) {
                        availableQuestions.push({
                            category: category,
                            question: question,
                            id: questionId
                        });
                    }
                });
            });
            
            // If all questions used, reset (shouldn't happen with 8 keys and enough questions)
            if (availableQuestions.length === 0) {
                usedQuestions = [];
                availableQuestions.push({
                    category: categories[0],
                    question: questionBank[categories[0]][0],
                    id: `${categories[0]}_0`
                });
            }
            
            const randomIndex = Math.floor(Math.random() * availableQuestions.length);
            const selectedQuestion = availableQuestions[randomIndex];
            usedQuestions.push(selectedQuestion.id);
            
            return selectedQuestion;
        }

        function showQuestion() {
            gameState.isPaused = true;
            gameState.questionsAnswered++;
            
            const questionData = getRandomQuestion();
            
            document.getElementById('questionCounter').textContent = `Question ${gameState.questionsAnswered} of 8`;
            document.getElementById('questionCategory').textContent = questionData.category;
            document.getElementById('questionText').textContent = questionData.question.question;
            
            const optionsContainer = document.getElementById('answerOptions');
            optionsContainer.innerHTML = '';
            
            questionData.question.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'answer-btn';
                button.textContent = `${String.fromCharCode(65 + index)}. ${option}`;
                button.onclick = () => answerQuestion(index, questionData.question.correct, button);
                optionsContainer.appendChild(button);
            });
            
            document.getElementById('questionModal').classList.remove('hidden');
        }

        function answerQuestion(selectedIndex, correctIndex, button) {
            const allButtons = document.querySelectorAll('.answer-btn');
            
            // Disable all buttons
            allButtons.forEach(btn => btn.style.pointerEvents = 'none');
            
            if (selectedIndex === correctIndex) {
                button.classList.add('correct');
                gameState.correctAnswers++;
                gameState.score += 100;
                
                setTimeout(() => {
                    closeQuestion();
                    checkWinCondition();
                }, 1500);
            } else {
                button.classList.add('incorrect');
                allButtons[correctIndex].classList.add('correct');
                gameState.score -= 25;
                
                setTimeout(() => {
                    closeQuestion();
                    checkWinCondition();
                }, 2000);
            }
            
            updateUI();
        }

        function skipQuestion() {
            gameState.score -= 50;
            updateUI();
            closeQuestion();
            checkWinCondition();
        }

        function closeQuestion() {
            document.getElementById('questionModal').classList.add('hidden');
            gameState.isPaused = false;
            
            // Reset answer buttons
            const allButtons = document.querySelectorAll('.answer-btn');
            allButtons.forEach(btn => {
                btn.classList.remove('correct', 'incorrect');
                btn.style.pointerEvents = 'auto';
            });
        }

        function checkWinCondition() {
            if (gameState.questionsAnswered >= 8) {
                if (gameState.correctAnswers === 8) {
                    showVictory();
                } else {
                    gameOver();
                }
            }
        }

        function loseLife() {
            gameState.lives--;
            updateUI();
            
            if (gameState.lives <= 0) {
                gameOver();
            } else {
                // Reset player position
                player.x = 60;
                player.y = 60;
            }
        }

        function gameOver() {
            gameState.isPlaying = false;
            gameLoopRunning = false;
            
            // Update high score
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                localStorage.setItem('studyQuestHighScore', gameState.highScore);
            }
            
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('finalCorrectAnswers').textContent = gameState.correctAnswers;
            document.getElementById('gameOverScreen').classList.remove('hidden');
            
            document.getElementById('gameHeader').style.display = 'none';
            document.getElementById('gameArea').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
        }

        function showVictory() {
            gameState.isPlaying = false;
            gameLoopRunning = false;
            
            // Update high score
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                localStorage.setItem('studyQuestHighScore', gameState.highScore);
            }
            
            document.getElementById('victoryScore').textContent = gameState.score;
            document.getElementById('victoryScreen').classList.remove('hidden');
            
            document.getElementById('gameHeader').style.display = 'none';
            document.getElementById('gameArea').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
        }

        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('victoryScreen').classList.add('hidden');
            startGame();
        }

        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('keys').textContent = gameState.keys;
            document.getElementById('correctAnswers').textContent = gameState.correctAnswers;
            document.getElementById('highScore').textContent = gameState.highScore;
            
            // Update lives display
            const livesContainer = document.getElementById('lives');
            livesContainer.innerHTML = '';
            for (let i = 0; i < gameState.lives; i++) {
                const life = document.createElement('div');
                life.className = 'life';
                livesContainer.appendChild(life);
            }
        }

        function render() {
            if (!gameCanvas || !ctx) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            
            // Draw walls
            ctx.fillStyle = '#37474f';
            ctx.strokeStyle = '#00bcd4';
            ctx.lineWidth = 2;
            walls.forEach(wall => {
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
                ctx.strokeRect(wall.x, wall.y, wall.width, wall.height);
            });
            
            // Draw collectibles
            collectibles.forEach(collectible => {
                ctx.save();
                ctx.translate(collectible.x, collectible.y);
                ctx.font = `${collectible.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(collectible.emoji, 0, 0);
                
                // Add glow effect
                ctx.shadowColor = '#ffeb3b';
                ctx.shadowBlur = 10;
                ctx.fillText(collectible.emoji, 0, 0);
                ctx.restore();
            });
            
            // Draw keys
            keyCollectibles.forEach(key => {
                ctx.save();
                ctx.translate(key.x, key.y);
                ctx.font = `${key.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(key.emoji, 0, 0);
                
                // Add glow effect
                ctx.shadowColor = '#ffc107';
                ctx.shadowBlur = 15;
                ctx.fillText(key.emoji, 0, 0);
                ctx.restore();
            });
            
            // Draw enemies
            enemies.forEach(enemy => {
                ctx.save();
                ctx.translate(enemy.x, enemy.y);
                
                // Draw enemy body
                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                ctx.arc(0, 0, enemy.size/2, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw enemy emoji
                ctx.font = `${enemy.size * 0.6}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(enemy.emoji, 0, 0);
                
                ctx.restore();
            });
            
            // Draw player
            ctx.save();
            ctx.translate(player.x, player.y);
            
            // Draw player body
            ctx.fillStyle = '#4caf50';
            ctx.strokeStyle = '#2e7d32';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, player.size/2, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            
            // Draw student emoji
            ctx.font = `${player.size * 0.7}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üéì', 0, 0);
            
            // Add glow effect
            ctx.shadowColor = '#4caf50';
            ctx.shadowBlur = 20;
            ctx.fillText('üéì', 0, 0);
            
            ctx.restore();
        }

        function gameLoop() {
            if (!gameLoopRunning || !gameState.isPlaying) return;
            
            if (!gameState.isPaused) {
                updateEnemies();
            }
            
            render();
            
            if (gameLoopRunning) {
                requestAnimationFrame(gameLoop);
            }
        }

    </script>
</body>
</html>
